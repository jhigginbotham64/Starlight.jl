var documenterSearchIndex = {"docs":
[{"location":"guide/walkthrough/app-lifecycle/#App-Lifecycle","page":"App Lifecycle","title":"App Lifecycle","text":"","category":"section"},{"location":"guide/walkthrough/app-lifecycle/","page":"App Lifecycle","title":"App Lifecycle","text":"Everything begins with \"the app\". Your great idea. The grand plan. The next big thing.","category":"page"},{"location":"guide/walkthrough/app-lifecycle/","page":"App Lifecycle","title":"App Lifecycle","text":"Living organisms have a lifecycle. Products have a development lifecycle. Software has a runtime lifecycle.","category":"page"},{"location":"guide/walkthrough/app-lifecycle/","page":"App Lifecycle","title":"App Lifecycle","text":"Your app is going to have a lifecycle. In fact, it's going to have multiple layers of lifecycles. Your framework needs to help you manage all of them.","category":"page"},{"location":"guide/walkthrough/app-lifecycle/","page":"App Lifecycle","title":"App Lifecycle","text":"Let's start with the basics. Apps manage a variety of interlocking components that need to communicate with each other. ","category":"page"},{"location":"guide/walkthrough/app-lifecycle/","page":"App Lifecycle","title":"App Lifecycle","text":"You can imagine having one \"master\" app managing a variety of \"components\" or \"subsystems\", which may be added or removed at random. These subsystems serve different purposes which can be represented by their types, and they manage data which may be contained in their instance.","category":"page"},{"location":"guide/walkthrough/app-lifecycle/","page":"App Lifecycle","title":"App Lifecycle","text":"So we can start with something like the following:","category":"page"},{"location":"guide/walkthrough/app-lifecycle/","page":"App Lifecycle","title":"App Lifecycle","text":"mutable struct App\n  systems::Dict{DataType, Any}\nend\n\nsystem!(a::App, s) = a.systems[typeof(s)] = s","category":"page"},{"location":"guide/walkthrough/app-lifecycle/","page":"App Lifecycle","title":"App Lifecycle","text":"This provides us with a simple mechanism to create a master app and add systems to it. But what kind of initialization needs to be performed? And how do you synchronize the initialization of the app with the initialization of the subsystems?","category":"page"},{"location":"guide/walkthrough/app-lifecycle/","page":"App Lifecycle","title":"App Lifecycle","text":"Well, for one thing, we're speaking in terms of a \"master\" app, so the singleton pattern may be appropriate (see Tom Kwong's book for an explanation of how this works in Julia).","category":"page"},{"location":"guide/walkthrough/app-lifecycle/","page":"App Lifecycle","title":"App Lifecycle","text":"const app = Ref{App}()\nconst app_lock = ReentrantLock()\n\nfunction App()\n  global app\n  global app_lock\n  lock(app_lock)\n  if !isassigned(app)\n    app[] = new(Dict{DataType, Any}())\n  end\n  unlock(app_lock)\n  return app[]\nend","category":"page"},{"location":"guide/walkthrough/app-lifecycle/","page":"App Lifecycle","title":"App Lifecycle","text":"Systems may be added or removed at any time, but they all need to be synchronized with the master app. This means we have a second initialization phase, as well as the need for a shutdown phase, and some indication of whether the master app is \"running\". Having a common subsystem interface for initialization and shutdown would greatly simplify things. ","category":"page"},{"location":"guide/walkthrough/app-lifecycle/","page":"App Lifecycle","title":"App Lifecycle","text":"We can add a field to our App, update the constructor, and add a couple of helper functions to get at on/off state:","category":"page"},{"location":"guide/walkthrough/app-lifecycle/","page":"App Lifecycle","title":"App Lifecycle","text":"mutable struct App\n  systems::Dict{DataType, Any}\n  running::Bool\nend\n\nfunction App()\n  ...\n  app[] = new(Dict{DataType, Any}(), false)\n  ...\nend\n\non(a::App) = a.running\noff(a::App) = !a.running","category":"page"},{"location":"guide/walkthrough/app-lifecycle/","page":"App Lifecycle","title":"App Lifecycle","text":"Now we can implement the following App lifecycle functions and use them as a starting point for our subsystem lifecycle interface:","category":"page"},{"location":"guide/walkthrough/app-lifecycle/","page":"App Lifecycle","title":"App Lifecycle","text":"awake!(s) = nothing\nshutdown!(s) = nothing\n\nfunction awake!(a::App)\n  if !on(a)\n    map(awake!, values(a.systems))\n    a.running = true\n  end\nend\n\nfunction shutdown!(a::App)\n  if !off(a)\n    map(shutdown!, values(a.systems))\n    a.running = false\n  end\nend","category":"page"},{"location":"guide/walkthrough/app-lifecycle/","page":"App Lifecycle","title":"App Lifecycle","text":"Let's throw in a little helper for use in scripts:","category":"page"},{"location":"guide/walkthrough/app-lifecycle/","page":"App Lifecycle","title":"App Lifecycle","text":"function run!(a::App)\n  awake!(a)\n  if !isinteractive()\n    while on(a)\n      yield()\n    end\n  end\nend","category":"page"},{"location":"guide/walkthrough/app-lifecycle/","page":"App Lifecycle","title":"App Lifecycle","text":"We now have a ready-made \"destructor\" for our App, trust us that our lives will be much easier if it gets called automatically:","category":"page"},{"location":"guide/walkthrough/app-lifecycle/","page":"App Lifecycle","title":"App Lifecycle","text":"function App()\n  ...\n  app[] = finalizer(shutdown!, \n          new(Dict{DataType, Any}(), false))\n  ...\nend","category":"page"},{"location":"guide/walkthrough/app-lifecycle/","page":"App Lifecycle","title":"App Lifecycle","text":"We can now define subsystems in terms of their awake! and shutdown! methods and add them to our App. We can also access the master App by simply calling its constructor with no arguments, i.e. App().","category":"page"},{"location":"guide/walkthrough/app-lifecycle/","page":"App Lifecycle","title":"App Lifecycle","text":"But we have no subsystems, and if they did they wouldn't do anything. Or rather, we have no mechanism for telling them what to do besides turning on and off. Time to fix that.","category":"page"},{"location":"guide/walkthrough/message-passing/#Message-Passing","page":"Message Passing","title":"Message Passing","text":"","category":"section"},{"location":"guide/walkthrough/message-passing/","page":"Message Passing","title":"Message Passing","text":"We alluded earlier to Starlight's microkernel architecture. This architecture is essentially a combination of Starlight's lifecycle functions and its message passing system.","category":"page"},{"location":"guide/walkthrough/message-passing/","page":"Message Passing","title":"Message Passing","text":"Returning to our \"framework from scratch\" narrative, we need a mechanism for telling subsystems what to do. Ideally we wouldn't have them busy-waiting for instructions, and we also want to maintain our mental model of subsystems executing independently of each other (even if running on a single thread). What we're describing is an event-driven programming model, and in fact the terms \"event handling\" and \"message passing\" are mostly interchangeable in Starlight's vocabulary.","category":"page"},{"location":"guide/walkthrough/message-passing/","page":"Message Passing","title":"Message Passing","text":"We'll need to manage a set of event handlers for each type of event. These \"handlers\" might also be called \"listeners\", and we can start by keeping them in a dictionary:","category":"page"},{"location":"guide/walkthrough/message-passing/","page":"Message Passing","title":"Message Passing","text":"const listeners = Dict{DataType, Set{Any}}()","category":"page"},{"location":"guide/walkthrough/message-passing/","page":"Message Passing","title":"Message Passing","text":"Event order may be important, and access to the queue needs to be synchronized since even on a single thread we don't know what order the subsystems will be running in. Julia provides Channels for exactly this use case:","category":"page"},{"location":"guide/walkthrough/message-passing/","page":"Message Passing","title":"Message Passing","text":"const messages = Channel(Inf)","category":"page"},{"location":"guide/walkthrough/message-passing/","page":"Message Passing","title":"Message Passing","text":"Now we can define simple functions for sending and listening for messages, throwing in a synchronization primitive since we're assuming a parallel environment:","category":"page"},{"location":"guide/walkthrough/message-passing/","page":"Message Passing","title":"Message Passing","text":"function sendMessage(m)\n  if haskey(listeners, typeof(m))\n    put!(messages, m)\n  end\nend\n\nconst listener_lock = ReentrantLock()\n\nfunction listenFor(e::Any, d::DataType)\n  lock(listener_lock)\n  if !haskey(listeners, d) listeners[d] = Set{Any}() end\n  push!(listeners[d], e)\n  unlock(listener_lock)\nend\n\nfunction unlistenFrom(e::Any, d::DataType)\n  lock(listener_lock)\n  if haskey(listeners, d) delete!(listeners[d], e) end\n  unlock(listener_lock)\nend","category":"page"},{"location":"guide/walkthrough/message-passing/","page":"Message Passing","title":"Message Passing","text":"...but receiving messages is a little bit trickier. We have listeners, but who tells them about events? Keeping that question in mind, we can write a function to dispatch a single message that can be called from wherever-because-we-don't-know-yet (note the trivial parallelization):","category":"page"},{"location":"guide/walkthrough/message-passing/","page":"Message Passing","title":"Message Passing","text":"handleMessage!(l, m) = nothing\n\nfunction dispatchMessage()\n  m = take!(messages)\n  d = typeof(m)\n  if haskey(listeners, d)\n    Threads.@threads for l in Vector([listeners[d]...])\n      handleMessage!(l, m)\n    end\n  end\nend","category":"page"},{"location":"guide/walkthrough/message-passing/","page":"Message Passing","title":"Message Passing","text":"...so, in theory, anyone who wants to receive an event could","category":"page"},{"location":"guide/walkthrough/message-passing/","page":"Message Passing","title":"Message Passing","text":"Define a custom data type\nCreate an instance of that data type\nCall listenFor with their instance\nHave their handleMessage! function invoked automatically when events are processed\nCall unlistenFrom when finished","category":"page"},{"location":"guide/walkthrough/message-passing/","page":"Message Passing","title":"Message Passing","text":"This is, in fact, exactly the workflow that subsystems implement in order to process events. Their awake! and shutdown! functions even provide the perfect opportunity to call listenFor and unlistenFrom respectively.","category":"page"},{"location":"guide/walkthrough/message-passing/","page":"Message Passing","title":"Message Passing","text":"But whose job is it to call dispatchMessage?","category":"page"},{"location":"guide/walkthrough/message-passing/","page":"Message Passing","title":"Message Passing","text":"Let's outline some requirements:","category":"page"},{"location":"guide/walkthrough/message-passing/","page":"Message Passing","title":"Message Passing","text":"Start processing messages when the App awake!s\nStop processing messages when the App shutdown!s\nRun \"in the background\" so that it can yield to other processes if there are no messages","category":"page"},{"location":"guide/walkthrough/message-passing/","page":"Message Passing","title":"Message Passing","text":"Sounds like our event dispatcher needs to run inside a coroutine managed by a subsystem that synchronizes tasks.","category":"page"},{"location":"guide/walkthrough/message-passing/","page":"Message Passing","title":"Message Passing","text":"But we're not quite there yet. To finally answer the question of what we actually need, we need to ask one further question: what events do the various subsystems listen for? We've assumed that they'll be running continuously, but also responding to events. How do you do both at the same time?","category":"page"},{"location":"guide/walkthrough/message-passing/","page":"Message Passing","title":"Message Passing","text":"One way is to model the passage of time as an event that subsystems listen for, and fire that event from another coroutine.","category":"page"},{"location":"guide/walkthrough/message-passing/","page":"Message Passing","title":"Message Passing","text":"For that we could use a Clock, which will be the first subsystem we implement.","category":"page"},{"location":"examples/pong/#Pong","page":"Pong","title":"Pong","text":"","category":"section"},{"location":"examples/pong/","page":"Pong","title":"Pong","text":"warning: Warning\nThis example assumes familiarity with Starlight's API, as well as with Telescope. It is more focused on describing how to use these libraries than on what they do.","category":"page"},{"location":"examples/pong/","page":"Pong","title":"Pong","text":"This example will walk you through the source code of Pong as implemented in Starlight's example subdirectory.","category":"page"},{"location":"examples/pong/","page":"Pong","title":"Pong","text":"First off, the obligatory","category":"page"},{"location":"examples/pong/","page":"Pong","title":"Pong","text":"using Starlight","category":"page"},{"location":"examples/pong/","page":"Pong","title":"Pong","text":"Then, since the maintainer hates hardcoding anything, there are a lot of configurable parameters. You can play around with these if you download the source code. Their usage should make sense once you see them in context. If you forget what one is or what its default value is, or just want to know where it's used, Ctrl-F is your friend. :)","category":"page"},{"location":"examples/pong/","page":"Pong","title":"Pong","text":"const window_width = 600\nconst window_height = 400\nconst paddle_width = 10\nconst paddle_height = 60\nconst ball_width = 10\nconst ball_height = 10\nconst wall_height = 10\nconst goal_width = 10\nconst hz = 1\n\n# collision margins\nconst wmx = 0 # wall\nconst wmy = 0\nconst gmx = 0 # goal\nconst gmy = 0\nconst pmx = 0 # paddle\nconst pmy = 0\nconst bmx = 0 # ball\nconst bmy = 0\n\nconst pv = window_height # paddle velocity\nconst ball_vel_x_mult = 0.25\nconst ball_vel_y_mult = 1.5\nconst ball_vel_x = ball_vel_x_mult * window_width\nconst ball_vel_y_max = ball_vel_y_mult * window_height\nconst paddle_ball_x_tolerance = 2\nball_vel_y(i) =  -i * ball_vel_y_max\nconst score_scale = 10\nconst score_y_offset = 50\nconst msg_scale = 2\nconst center_line_dash_w = 10\nconst center_line_dash_h = 40\nconst center_line_dash_spacing = 20\nconst asset_base = joinpath(artifact\"test\", \"test\")\nconst secs_between_rounds = 2\nconst score_to_win = 10","category":"page"},{"location":"examples/pong/","page":"Pong","title":"Pong","text":"Create an App with the given settings, and make sure to set the background to black instead of using the default grey:","category":"page"},{"location":"examples/pong/","page":"Pong","title":"Pong","text":"a = App(; wdth=window_width, hght=window_height, bgrd=colorant\"black\")","category":"page"},{"location":"examples/pong/","page":"Pong","title":"Pong","text":"We can now begin defining the static UI elements, like the centerline and scores, i.e. things that don't require their own message handlers. ","category":"page"},{"location":"examples/pong/","page":"Pong","title":"Pong","text":"We can start with the center line, which is an array of ColorRects evenly spaced between the two walls:","category":"page"},{"location":"examples/pong/","page":"Pong","title":"Pong","text":"center_line = []\nfor i in (wall_height + center_line_dash_spacing):\\\n  (center_line_dash_h + center_line_dash_spacing):\\\n  (window_height - wall_height - center_line_dash_h - center_line_dash_spacing)\n  push!(center_line, ColorRect(center_line_dash_w, center_line_dash_h; \n  color=colorant\"grey\", pos=XYZ((window_width - center_line_dash_w) / 2, i)))\nend","category":"page"},{"location":"examples/pong/","page":"Pong","title":"Pong","text":"Next we'll use Julia's Artifacts system to pull in a couple of public-domain spritesheets that we'll be using for text. But first, if we want to define things in terms of text strings, and since we're not using a standard format like TTF, we need to define what characters belong to which cells on the spritesheet. Feel free to just scroll past this, it's only included for the sake of completeness, normally such things would be handled by an asset importer or something, but we don't have anything like that for Starlight yet.","category":"page"},{"location":"examples/pong/","page":"Pong","title":"Pong","text":"cpchars = Dict(\n  ' ' => [0,0],\n  '!' => [0,1],\n  '\\\"' => [0,2],\n  '#' => [0,3],\n  '$' => [0,4],\n  '%' => [0,5],\n  '&' => [0,6],\n  '\\'' => [0,7],\n  '(' => [0,8],\n  ')' => [0,9],\n  '*' => [0,10],\n  '+' => [0,11],\n  ',' => [0,12],\n  '-' => [0,13],\n  '.' => [0,14],\n  '/' => [0,15],\n  '0' => [0,16],\n  '1' => [0,17],\n  '2' => [1,0],\n  '3' => [1,1],\n  '4' => [1,2],\n  '5' => [1,3],\n  '6' => [1,4],\n  '7' => [1,5],\n  '8' => [1,6],\n  '9' => [1,7],\n  ':' => [1,8],\n  ';' => [1,9],\n  '<' => [1,10],\n  '=' => [1,11],\n  '>' => [1,12],\n  '?' => [1,13],\n  '@' => [1,14],\n  'A' => [1,15],\n  'B' => [1,16],\n  'C' => [1,17],\n  'D' => [2,0],\n  'E' => [2,1],\n  'F' => [2,2],\n  'G' => [2,3],\n  'H' => [2,4],\n  'I' => [2,5],\n  'J' => [2,6],\n  'K' => [2,7],\n  'L' => [2,8],\n  'M' => [2,9],\n  'N' => [2,10],\n  'O' => [2,11],\n  'P' => [2,12],\n  'Q' => [2,13],\n  'R' => [2,14],\n  'S' => [2,15],\n  'T' => [2,16],\n  'U' => [2,17],\n  'V' => [3,0],\n  'W' => [3,1],\n  'X' => [3,2],\n  'Y' => [3,3],\n  'Z' => [3,4],\n  '[' => [3,5],\n  '\\\\' => [3,6],\n  ']' => [3,7],\n  '^' => [3,8],\n  '_' => [3,9],\n  '`' => [3,10],\n  'a' => [3,11],\n  'b' => [3,12],\n  'c' => [3,13],\n  'd' => [3,14],\n  'e' => [3,15],\n  'f' => [3,16],\n  'g' => [3,17],\n  'h' => [4,0],\n  'i' => [4,1],\n  'j' => [4,2],\n  'k' => [4,3],\n  'l' => [4,4],\n  'm' => [4,5],\n  'n' => [4,6],\n  'o' => [4,7],\n  'p' => [4,8],\n  'q' => [4,9],\n  'r' => [4,10],\n  's' => [4,11],\n  't' => [4,12],\n  'u' => [4,13],\n  'v' => [4,14],\n  'w' => [4,15],\n  'x' => [4,16],\n  'y' => [4,17],\n  'z' => [5,0],\n  '{' => [5,1],\n  '|' => [5,2],\n  '}' => [5,3],\n  '~' => [5,4],\n)","category":"page"},{"location":"examples/pong/","page":"Pong","title":"Pong","text":"Now our text strings are going to be composed of sprites, so we'll have some of the normal sprite attributes in addition to one that tells us which spritesheet to use:","category":"page"},{"location":"examples/pong/","page":"Pong","title":"Pong","text":"mutable struct CellphoneString <: Renderable\n  function CellphoneString(str=\"\", white=true; \n    scale=XYZ(1,1), color=colorant\"white\", kw...)\n    instantiate!(new(); str=str, white=white, scale=scale, color=color, kw...)\n  end\nend","category":"page"},{"location":"examples/pong/","page":"Pong","title":"Pong","text":"Now we can define its draw function, which determines which spritesheet to use and draws each character based on its position in the spritesheet:","category":"page"},{"location":"examples/pong/","page":"Pong","title":"Pong","text":"function Starlight.draw(s::CellphoneString)\n  img = (s.white) ? joinpath(asset_base,\n                      \"sprites\", \"charmap-cellphone_white.png\") : \\\n                    joinpath(asset_base, \n                      \"sprites\", \"charmap-cellphone_black.png\")\n  for (i,c) in enumerate(s.str)\n    cell_ind = cpchars[c]\n    TS_VkCmdDrawSprite(img, vulkan_colors(s.color)...,\n    0, 0, 0, 0,\n    7, 9, cell_ind[1], cell_ind[2],\n    Int(floor(s.scale.x * 7)) * (i - 1) + s.abs_pos.x, s.abs_pos.y, \n              s.scale.x, s.scale.y)\n  end\nend","category":"page"},{"location":"examples/pong/","page":"Pong","title":"Pong","text":"Note that for this and all other method \"overloads\", you must specify Starlight. or Julia will assume you want to define a method with that name inside the Main module and nothing will work.","category":"page"},{"location":"examples/pong/","page":"Pong","title":"Pong","text":"Now, with all that complexity out of the way, we are free to write some excessively simple UI code (well, if you don't count the positioning calculations):","category":"page"},{"location":"examples/pong/","page":"Pong","title":"Pong","text":"# p1 score\nscore1 = CellphoneString('0'; color=colorant\"grey\", \n  scale=XYZ(score_scale, score_scale), \n  pos=XYZ((window_width / 2) - (window_width / 4) - \n  (7 * score_scale / 2), score_y_offset))\n\n# p2 score\nscore2 = CellphoneString('0'; color=colorant\"grey\", \n  scale=XYZ(score_scale, score_scale), \n  pos=XYZ((window_width / 2) + (window_width / 4) - \n  (7 * score_scale / 2), score_y_offset))\n\n# welcome message\nmsg = CellphoneString(\"Press SPACE to start\", false; \n  scale=XYZ(msg_scale, msg_scale), \n  pos=XYZ((window_width - 140 * msg_scale) / 2, \n  (window_height - 9 * msg_scale) / 2))","category":"page"},{"location":"examples/pong/","page":"Pong","title":"Pong","text":"We're going to start handholding even less now. By this point you should be well up to speed on how Starlight works.","category":"page"},{"location":"examples/pong/","page":"Pong","title":"Pong","text":"Our paddles are simple rectangles, so we can reuse the defaultDrawRect function. Notice the (recommended) pattern of managing physics entities inside awake! and shutdown! rather than in the constructor and finalizer. This is so that entities can be awoken and shutdown without Bullet continuing to simulate them, and also without other subsystems needing to know about physics.","category":"page"},{"location":"examples/pong/","page":"Pong","title":"Pong","text":"Recall that Bullet uses half extents for its box shapes, so we calculate and then use those here.","category":"page"},{"location":"examples/pong/","page":"Pong","title":"Pong","text":"Probably the most interesting \"new\" thing here is the collision handler, which deals with paddle/wall contacts. pg is something we'll see later, it refers to an instance of a PongGame entity that handles game state and input. Basically this collision handler tells the game manager whether to allow paddle movement in a particular direction.","category":"page"},{"location":"examples/pong/","page":"Pong","title":"Pong","text":"mutable struct PongPaddle <: Starlight.Renderable \n  function PongPaddle(w, h; kw...)\n    instantiate!(new(); w=w, h=h, color=colorant\"white\", kw...)\n  end\nend\n\nStarlight.draw(p::PongPaddle) = defaultDrawRect(p)\n\nfunction Starlight.awake!(p::PongPaddle)\n  hw = paddle_width / 2\n  hh = paddle_height / 2\n  addTriggerBox!(p, hw, hh, hz, p.pos.x + hw, p.pos.y + hh, 0, pmx, pmy, 0)\nend\n\nfunction Starlight.shutdown!(p::PongPaddle)\n  removePhysicsObject!(p)\nend\n\nfunction Starlight.handleMessage!(p::PongPaddle, col::TS_CollisionEvent)\n  otherId = other(p, col)\n  if otherId == wallt.id\n    if p.id == p1.id\n      pg.p1TouchingTopWall = col.colliding\n    elseif p.id == p2.id\n      pg.p2TouchingTopWall = col.colliding\n    end\n  elseif otherId == wallb.id\n    if p.id == p1.id\n      pg.p1TouchingBottomWall = col.colliding\n    elseif p.id == p2.id\n      pg.p2TouchingBottomWall = col.colliding\n    end\n  end\nend\n\n# p1\np1 = PongPaddle(paddle_width, paddle_height; \n  pos=XYZ(paddle_width, (window_height - paddle_height) / 2))\n\n# p2\np2 = PongPaddle(paddle_width, paddle_height; \n  pos=XYZ(window_width - 2 * paddle_width, \n  (window_height - paddle_height) / 2))","category":"page"},{"location":"examples/pong/","page":"Pong","title":"Pong","text":"Comparatively there is nothing special about the walls or goals, except that one gets drawn and the other doesn't:","category":"page"},{"location":"examples/pong/","page":"Pong","title":"Pong","text":"mutable struct PongArenaWall <: Starlight.Renderable\n  function PongArenaWall(w, h; kw...)\n    instantiate!(new(); w=w, h=h, color=colorant\"white\", kw...)\n  end\nend\n\nStarlight.draw(p::PongArenaWall) = defaultDrawRect(p)\n\nfunction Starlight.awake!(p::PongArenaWall)\n  hw = window_width / 2\n  hh = wall_height / 2\n  addTriggerBox!(p, hw, hh, hz, p.pos.x + hw, p.pos.y + hh, 0, wmx, wmy, 0)\nend\n\nfunction Starlight.shutdown!(p::PongArenaWall)\n  removePhysicsObject!(p)\nend\n\n# top wall\nwallt = PongArenaWall(window_width, wall_height; pos=XYZ(0, 0))\n\n# bottom wall\nwallb = PongArenaWall(window_width, wall_height; \n  pos=XYZ(0, window_height - wall_height))\n\nmutable struct PongArenaGoal <: Starlight.Entity\n  function PongArenaGoal(w, h; kw...)\n    instantiate!(new(); w=w, h=h, kw...)\n  end\nend\n\nfunction Starlight.awake!(p::PongArenaGoal)\n  hw = goal_width / 2\n  hh = window_height / 2\n  addTriggerBox!(p, hw, hh, hz, p.pos.x + hw, p.pos.y + hh, 0, gmx, gmy, 0)\nend\n\nfunction Starlight.shutdown!(p::PongArenaGoal)\n  removePhysicsObject!(p)\nend\n\n# left goal\ngoal1 = PongArenaGoal(window_height * 2, goal_width; \n  pos=XYZ(-goal_width, 0))\n\n# right goal\ngoal2 = PongArenaGoal(window_height * 2, goal_width; \n  pos=XYZ(window_width, 0))","category":"page"},{"location":"examples/pong/","page":"Pong","title":"Pong","text":"The ball is a simple rectangle, but its collision handler is where most of the game logic is run. Let's get the easy stuff out of the way:","category":"page"},{"location":"examples/pong/","page":"Pong","title":"Pong","text":"mutable struct PongBall <: Starlight.Renderable\n  function PongBall(w, h; kw...)\n    instantiate!(new(); w=w, h=h, color=colorant\"white\", kw...)\n  end \nend\n\nStarlight.draw(p::PongBall) = defaultDrawRect(p)\n\nfunction Starlight.awake!(p::PongBall)\n  hw = ball_width / 2\n  hh = ball_height / 2\n  addTriggerBox!(p, hw, hh, hz, p.pos.x + hw, p.pos.y + hh, 0, bmx, bmy, 0)\nend\n\nfunction Starlight.shutdown!(p::PongBall)\n  removePhysicsObject!(p)\nend","category":"page"},{"location":"examples/pong/","page":"Pong","title":"Pong","text":"...and now, the hard part. We confess that this Pong implementation is buggy, and a few of the bugs are in the following code. If you can fix them, please submit a pull request, we would greatly appreciate it.","category":"page"},{"location":"examples/pong/","page":"Pong","title":"Pong","text":"Understand that this is mostly \"Pong logic\" however: there's not much here that's instructive about Starlight, except that it shows you how different components can be used to implement the logic of an actual game.","category":"page"},{"location":"examples/pong/","page":"Pong","title":"Pong","text":"Combined with everything we've already covered, we have no compunction telling you to simply read the code if you're interested in it. :)","category":"page"},{"location":"examples/pong/","page":"Pong","title":"Pong","text":"function hit_edge(p::PongBall, o::PongPaddle)\n  if o.id == p1.id # left\n    return p.abs_pos.x < (o.abs_pos.x + paddle_width - paddle_ball_x_tolerance)\n  else # right\n    return p.abs_pos.x > (o.abs_pos.x - ball_width + paddle_ball_x_tolerance)\n  end\nend\n\nfunction hit_angle(p::PongBall, o::PongPaddle)\n  paddle_top = o.abs_pos.y - ball_height / 2\n  ball_center = p.abs_pos.y + ball_height / 2\n  paddle_hit_area = paddle_height + ball_height\n  return -(2 * ((ball_center - paddle_top) / paddle_hit_area) - 1)\nend\n\nfunction wait_and_start_new_round(arg)\n  sleep(SLEEP_SEC(secs_between_rounds))\n  pg.ball = newball()\nend\n\ngetP1Score() = parse(Int, score1.str)\ngetP2Score() = parse(Int, score2.str)\n\nfunction Starlight.handleMessage!(p::PongBall, col::TS_CollisionEvent)\n  otherId = other(p, col)\n  vel = TS_BtGetLinearVelocity(p.id)\n  if col.colliding\n    if otherId ∈ [wallt.id, wallb.id]\n      TS_PlaySound(joinpath(asset_base, \n        \"sounds\", \"ping_pong_8bit_plop.ogg\"), 0, -1)\n      TS_BtSetLinearVelocity(p.id, vel.x, -vel.y, vel.z)\n    elseif otherId ∈ [goal1.id, goal2.id]\n      TS_PlaySound(joinpath(asset_base, \n        \"sounds\", \"ping_pong_8bit_peeeeeep.ogg\"), 0, -1)\n      destroy!(p)\n\n      if otherId == goal2.id\n        score1.str = string(getP1Score() + 1)\n      elseif otherId == goal1.id\n        score2.str = string(getP2Score() + 1)\n      end\n\n      if getP1Score() == score_to_win || getP2Score() == score_to_win\n        msg.hidden = false\n        score1.str = \"0\"\n        score2.str = \"0\"\n      else\n        oneshot!(clk(), wait_and_start_new_round)\n      end\n    elseif otherId ∈ [p1.id, p2.id]\n      TS_PlaySound(joinpath(asset_base, \n        \"sounds\", \"ping_pong_8bit_beeep.ogg\"), 0, -1)\n      o = getEntityById(otherId)\n      TS_BtSetLinearVelocity(p.id, (hit_edge(p, o) ? 1 : -1) * vel.x,\n        ball_vel_y(hit_angle(p, o)), vel.z)\n    end\n  end\nend","category":"page"},{"location":"examples/pong/","page":"Pong","title":"Pong","text":"The PongGame does however have a few interesting things about it. It shows the use of input events and how they can help manage game state, as well as the recommended way to exit out of a Starlight app: defining an SDL_QuitEvent handler. Leaving this up to the user allows them to define custom behavior like \"Do you really want to quit?\" dialogs.","category":"page"},{"location":"examples/pong/","page":"Pong","title":"Pong","text":"mutable struct PongGame <: Starlight.Entity\n  function PongGame() \n    instantiate!(new(); ball=nothing, w=false, s=false, up=false, down=false, \n      p1TouchingTopWall=false, p2TouchingTopWall=false, \n      p1TouchingBottomWall=false, p2TouchingBottomWall=false)\n  end\nend\n\nfunction Starlight.awake!(p::PongGame)\n  listenFor(p, SDL_KeyboardEvent)\n  listenFor(p, SDL_QuitEvent)\n  TS_BtSetGravity(0, 0, 0)\nend\n\nfunction Starlight.shutdown!(p::PongGame)\n  unlistenFrom(p, SDL_KeyboardEvent)\n  unlistenFrom(p, SDL_QuitEvent)\nend\n\nfunction newball()\n  p = PongBall(ball_width, ball_height; \n    pos=XYZ((window_width - ball_width) / 2, \n    (window_height - ball_height) / 2))\n  TS_BtSetLinearVelocity(p.id, \n    ((rand(Bool)) ? 1 : -1) * ball_vel_x, ball_vel_y(2 * rand() - 1), 0)\n  return p\nend\n\nfunction Starlight.handleMessage!(p::PongGame, key::SDL_KeyboardEvent)\n  if key.keysym.scancode == SDL_SCANCODE_SPACE && !msg.hidden\n    msg.hidden = true\n    p.ball = newball()\n  elseif key.keysym.scancode == SDL_SCANCODE_W\n    p.w = key.state == SDL_PRESSED\n  elseif key.keysym.scancode == SDL_SCANCODE_S\n    p.s = key.state == SDL_PRESSED\n  elseif key.keysym.scancode == SDL_SCANCODE_UP\n    p.up = key.state == SDL_PRESSED\n  elseif key.keysym.scancode == SDL_SCANCODE_DOWN\n    p.down = key.state == SDL_PRESSED\n  end\nend\n\n\nfunction Starlight.handleMessage!(p::PongGame, q::SDL_QuitEvent)\n  shutdown!(p)\nend\n\nfunction Starlight.update!(p::PongGame, Δ::AbstractFloat)\n  TS_BtSetLinearVelocity(p1.id, 0, 0, 0)\n  TS_BtSetLinearVelocity(p2.id, 0, 0, 0)\n  if p.w && !p.p1TouchingTopWall\n    TS_BtSetLinearVelocity(p1.id, 0, -pv, 0)\n  elseif p.s && !p.p1TouchingBottomWall\n    TS_BtSetLinearVelocity(p1.id, 0, pv, 0)\n  end\n  if p.up && !p.p2TouchingTopWall\n    TS_BtSetLinearVelocity(p2.id, 0, -pv, 0)\n  elseif p.down && !p.p2TouchingBottomWall\n    TS_BtSetLinearVelocity(p2.id, 0, pv, 0)\n  end\nend\n\npg = PongGame()","category":"page"},{"location":"examples/pong/","page":"Pong","title":"Pong","text":"And with that, all that's left to do is run the App:","category":"page"},{"location":"examples/pong/","page":"Pong","title":"Pong","text":"run!(a)","category":"page"},{"location":"examples/pong/","page":"Pong","title":"Pong","text":"And...that's Pong with Starlight!","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Starlight","category":"page"},{"location":"api/#Starlight","page":"API","title":"Starlight","text":"Main module for Starlight.jl - a greedy framework for greedy developers.\n\nReexports\n\nBase: ReentrantLock, lock, unlock\nFileIO: load\nPkg.Artifacts\nLazyArtifacts\nDataStructures: Queue, enqueue!, dequeue!\nDataFrames\nColors\nSimpleDirectMediaLayer\nSimpleDirectMediaLayer.LibSDL2\nTelescope\n\n\n\n\n\n","category":"module"},{"location":"api/#Core","page":"API","title":"Core","text":"","category":"section"},{"location":"api/#App-and-Events","page":"API","title":"App and Events","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"awake!(::Any)\nshutdown!(::Any)\nlisteners\nmessages\nlistener_lock\nhandleMessage!(::Any, ::Any)\nsendMessage(::Any)\nlistenFor(::Any, ::DataType)\nunlistenFrom(::Any, ::DataType)\nhandleException\ndispatchMessage\nApp\non\noff\nsystem!\nclk\necs\ninp\nts\nphys\nscn\nsystemAwakeOrder\nsystemShutdownOrder\nawake!(::App)\nshutdown!(::App)\nrun!","category":"page"},{"location":"api/#Starlight.awake!-Tuple{Any}","page":"API","title":"Starlight.awake!","text":"awake!(a) = nothing\n\nArbitrary startup function.\n\nBy default does literally nothing, but methods can be added for any type.\n\nThe preferred way to call listenFor is from inside an awake! method.\n\n\n\n\n\n","category":"method"},{"location":"api/#Starlight.shutdown!-Tuple{Any}","page":"API","title":"Starlight.shutdown!","text":"shutdown!(a) = nothing\n\nArbitrary shutdown function.\n\nBy default does literally nothing, but methods can be added for any type.\n\nThe preferred way to call unlistenFrom is from inside a shutdown! method.\n\n\n\n\n\n","category":"method"},{"location":"api/#Starlight.listeners","page":"API","title":"Starlight.listeners","text":"const listeners = Dict{DataType, Set{Any}}()\n\nInternal dictionary that pairs event types with their listeners.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Starlight.messages","page":"API","title":"Starlight.messages","text":"const messages = Channel(Inf)\n\nInternal Channel used to hold messages.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Starlight.listener_lock","page":"API","title":"Starlight.listener_lock","text":"const listener_lock = ReentrantLock()\n\nInternal lock used to synchronize access to the listeners dictionary.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Starlight.handleMessage!-Tuple{Any, Any}","page":"API","title":"Starlight.handleMessage!","text":"handleMessage!(l, m) = nothing\n\nInvoked on listener l when message m is received.\n\nCurrently there are three ways this function can be invoked for a given listener and message:\n\nautomatically by the message dispatcher, when the listener has been registered with listenFor and the message is of the corresponding type\nautomatically by the Physics subsystem on two colliding objects with message type TS_CollisionEvent\nmanually by user code (discouraged)\n\nBy default does (literally) nothing, but methods can be added for any type combination.\n\n\n\n\n\n","category":"method"},{"location":"api/#Starlight.sendMessage-Tuple{Any}","page":"API","title":"Starlight.sendMessage","text":"function sendMessage(m)\n  if haskey(listeners, typeof(m))\n    put!(messages, m)\n  end\nend\n\nAdd a message to the message queue if the message's type has any listeners. Otherwise drop.\n\nThe preferred way to send events/messages in Starlight.\n\n\n\n\n\n","category":"method"},{"location":"api/#Starlight.listenFor-Tuple{Any, DataType}","page":"API","title":"Starlight.listenFor","text":"function listenFor(e::Any, d::DataType)\n  lock(listener_lock)\n  if !haskey(listeners, d) listeners[d] = Set{Any}() end\n  push!(listeners[d], e)\n  unlock(listener_lock)\nend\n\nAdd a listener e for messages of type d. l's handleMessage! method will be invoked when messages of type d are received.\n\n\n\n\n\n","category":"method"},{"location":"api/#Starlight.unlistenFrom-Tuple{Any, DataType}","page":"API","title":"Starlight.unlistenFrom","text":"function unlistenFrom(e::Any, d::DataType)\n  lock(listener_lock)\n  if haskey(listeners, d) delete!(listeners[d], e) end\n  unlock(listener_lock)\nend\n\nStop listener e from receiving messages of type d.\n\n\n\n\n\n","category":"method"},{"location":"api/#Starlight.handleException","page":"API","title":"Starlight.handleException","text":"function handleException()\n  for s in stacktrace(catch_backtrace())\n    println(s)\n  end\n  shutdown!(App())\nend\n\nPrint a stacktrace and exit gracefully.\n\n\n\n\n\n","category":"function"},{"location":"api/#Starlight.dispatchMessage","page":"API","title":"Starlight.dispatchMessage","text":"function dispatchMessage(arg)\n  try\n    m = take!(messages) # NOTE messages are fully processed in the order they are received\n    d = typeof(m)\n    if haskey(listeners, d)\n      # Threads.@threads doesn't work on raw sets\n      # because it needs to use indexing to split\n      # up memory, i work around it this way\n      Threads.@threads for l in Vector([listeners[d]...])\n        handleMessage!(l, m)\n      end\n    end\n  catch\n    handleException()\n  end\nend\n\nTake a single message from the event queue and invoke handleMessage! for all listeners in parallel. \n\nIf there are no listeners for the message type (i.e. they were removed after the message was sent), drop.\n\nNormally runs in an infinite loop in a background Task started by awake!(::App).\n\ndanger: Danger\nThis function is called internally by Starlight and documented here for completeness. Do not invoke it yourself unless you know what you are doing.\n\n\n\n\n\n","category":"function"},{"location":"api/#Starlight.App","page":"API","title":"Starlight.App","text":"Struct for the \"master App\" singleton.\n\nConstructor accepts keyword arguments for all fields except systems, and no positional arguments.\n\nFields\n\nsystems::Dict{DataType, Any} Dictionary of subsystems by type\nrunning::Bool Whether awake! has been called\nwdth::Int Window width\nhght::Int Window height\nbgrd::Colorant Window default background color\n\n\n\n\n\n","category":"type"},{"location":"api/#Starlight.on","page":"API","title":"Starlight.on","text":"on(a::App) = a.running\n\nCheck whether awake! has been called.\n\n\n\n\n\n","category":"function"},{"location":"api/#Starlight.off","page":"API","title":"Starlight.off","text":"off(a::App) = !a.running\n\nOpposite of on.\n\n\n\n\n\n","category":"function"},{"location":"api/#Starlight.system!","page":"API","title":"Starlight.system!","text":"system!(a::App, s) = a.systems[typeof(s)] = s\n\nAdd something to an App's systems dictionary.\n\n\n\n\n\n","category":"function"},{"location":"api/#Starlight.clk","page":"API","title":"Starlight.clk","text":"clk() = App().systems[Clock]\n\nGet the current Clock.\n\n\n\n\n\n","category":"function"},{"location":"api/#Starlight.ecs","page":"API","title":"Starlight.ecs","text":"ecs() = App().systems[ECS]\n\nGet the current Entity Component System.\n\n\n\n\n\n","category":"function"},{"location":"api/#Starlight.inp","page":"API","title":"Starlight.inp","text":"inp() = App().systems[Input]\n\nGet the current Input manager.\n\n\n\n\n\n","category":"function"},{"location":"api/#Starlight.ts","page":"API","title":"Starlight.ts","text":"ts() = App().systems[TS]\n\nGet the current Telescope backend subsystem.\n\n\n\n\n\n","category":"function"},{"location":"api/#Starlight.phys","page":"API","title":"Starlight.phys","text":"phys() = App().systems[Physics]\n\nGet the current Physics manager.\n\n\n\n\n\n","category":"function"},{"location":"api/#Starlight.scn","page":"API","title":"Starlight.scn","text":"scn() = App().systems[Scene]\n\nGet the current Scene graph.\n\n\n\n\n\n","category":"function"},{"location":"api/#Starlight.systemAwakeOrder","page":"API","title":"Starlight.systemAwakeOrder","text":"systemAwakeOrder = () -> [clk(), ts(), inp(), phys(), ecs(), scn()]\n\nThe order in which App subsystems should be awoken in order to not produce bugs.\n\n\n\n\n\n","category":"function"},{"location":"api/#Starlight.systemShutdownOrder","page":"API","title":"Starlight.systemShutdownOrder","text":"systemShutdownOrder = () -> [clk(), inp(), phys(), scn(), ecs(), ts()]\n\nThe order in which App subsystems should be shut down in order to not produce bugs.\n\n\n\n\n\n","category":"function"},{"location":"api/#Starlight.awake!-Tuple{App}","page":"API","title":"Starlight.awake!","text":"function awake!(a::App)\n  if !on(a)\n    job!(clk(), dispatchMessage)\n    map(awake!, systemAwakeOrder())\n    a.running = true\n  end\nend\n\nIf not on, start the message dispatcher call awake! on all subsystems.\n\nNote that if running from a script the app will still exit when Julia exits, it will never block. Figuring out whether/how to keep it alive is on the user. One method is to use run!, see below.\n\n\n\n\n\n","category":"method"},{"location":"api/#Starlight.shutdown!-Tuple{App}","page":"API","title":"Starlight.shutdown!","text":"function shutdown!(a::App)\n  if !off(a)\n    map(shutdown!, systemShutdownOrder())\n    a.running = false\n  end\nend\n\nIf not off, call shutdown! on all subsystems.\n\n\n\n\n\n","category":"method"},{"location":"api/#Starlight.run!","page":"API","title":"Starlight.run!","text":"function run!(a::App)\n  awake!(a)\n  if !isinteractive()\n    while on(a)\n      yield()\n    end\n  end\nend\n\nCall awake! and keep alive until switched off.\n\n\n\n\n\n","category":"function"},{"location":"api/#Clock","page":"API","title":"Clock","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Clock\nTICK\nSLEEP_SEC\nSLEEP_NSEC\nsleep(::SLEEP_SEC)\nsleep(::SLEEP_NSEC)\ntick\njob!\noneshot!\nawake!(::Clock)\nshutdown!(::Clock)","category":"page"},{"location":"api/#Starlight.Clock","page":"API","title":"Starlight.Clock","text":"mutable struct Clock\n  started::Base.Event\n  stopped::Bool\n  freq::AbstractFloat\n  Clock() = new(Base.Event(), true, 0.01667)\nend\n\nFields\n\nstarted::Base.Event Whether awake! has been called\nstopped::Bool Whether shutdown! has been called\nfreq::AbstractFloat Tick frequency\n\n\n\n\n\n","category":"type"},{"location":"api/#Starlight.TICK","page":"API","title":"Starlight.TICK","text":"struct TICK\n  Δ::AbstractFloat # seconds\nend\n\n\n\n\n\n","category":"type"},{"location":"api/#Starlight.SLEEP_SEC","page":"API","title":"Starlight.SLEEP_SEC","text":"struct SLEEP_SEC\n  Δ::AbstractFloat\nend\n\n\n\n\n\n","category":"type"},{"location":"api/#Starlight.SLEEP_NSEC","page":"API","title":"Starlight.SLEEP_NSEC","text":"struct SLEEP_NSEC\n  Δ::UInt\nend\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.sleep-Tuple{SLEEP_SEC}","page":"API","title":"Base.sleep","text":"function Base.sleep(s::SLEEP_SEC)\n  t1 = time()\n  while true\n    if time() - t1 >= s.Δ break end\n    yield()\n  end\n  return time() - t1\nend\n\nSleep the specified number of seconds.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.sleep-Tuple{SLEEP_NSEC}","page":"API","title":"Base.sleep","text":"function Base.sleep(s::SLEEP_NSEC)\n  t1 = time_ns()\n  while true\n    if time_ns() - t1 >= s.Δ break end\n    yield()\n  end\n  return time_ns() - t1\nend\n\nSleep the specified number of nanoseconds.\n\n\n\n\n\n","category":"method"},{"location":"api/#Starlight.tick","page":"API","title":"Starlight.tick","text":"function tick(Δ)\n  δ = sleep(SLEEP_NSEC(Δ * 1e9))\n  sendMessage(TICK(δ / 1e9))\nend\n\nSleep Δ seconds, the raise a TICK event with the actual amount of time slept.\n\nCalled in a background task in an infinite loop.\n\nPrimary purpose is to trigger subsystem TICK handlers.\n\n\n\n\n\n","category":"function"},{"location":"api/#Starlight.job!","page":"API","title":"Starlight.job!","text":"function job!(c::Clock, f, arg=1)\n  function job()\n    Base.wait(c.started)\n    while !c.stopped\n      f(arg)\n    end\n  end\n  schedule(Task(job))\nend\n\nSchedule a background task to be run and synchronized with clock state.\n\nUsed internally to run dispatchMessage and tick.\n\n\n\n\n\n","category":"function"},{"location":"api/#Starlight.oneshot!","page":"API","title":"Starlight.oneshot!","text":"function oneshot!(c::Clock, f, arg=1)\n  function oneshot()\n    Base.wait(c.started)\n    f(arg)\n  end\n  schedule(Task(oneshot))\nend\n\nSchedule a background task to be run once, synchronized with Clock state.\n\n\n\n\n\n","category":"function"},{"location":"api/#Starlight.awake!-Tuple{Clock}","page":"API","title":"Starlight.awake!","text":"function awake!(c::Clock)\n  job!(c, tick, c.freq)\n\n  c.stopped = false\n\n  Base.notify(c.started)\nend\n\nStarts the tick job and signals all waiting Tasks that the clock has started.\n\n\n\n\n\n","category":"method"},{"location":"api/#Starlight.shutdown!-Tuple{Clock}","page":"API","title":"Starlight.shutdown!","text":"function shutdown!(c::Clock)\n  c.stopped = true\n  \n  c.started = Base.Event()\nend\n\nSignal Tasks that the Clock has stopped.\n\n\n\n\n\n","category":"method"},{"location":"api/#ECS-and-Scene","page":"API","title":"ECS and Scene","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/#Telescope-Backend","page":"API","title":"Telescope Backend","text":"","category":"section"},{"location":"api/#Rendering","page":"API","title":"Rendering","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/#Entities","page":"API","title":"Entities","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/#Input","page":"API","title":"Input","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/#Physics","page":"API","title":"Physics","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"guide/walkthrough/ecs/#Entity-Component-System","page":"Entity Component System","title":"Entity Component System","text":"","category":"section"},{"location":"guide/walkthrough/ecs/","page":"Entity Component System","title":"Entity Component System","text":"An Entity Component System (or \"ECS\" for short) is an in-memory object database where rows are instances and columns are properties. Arbitrary properties can be supported if one or more of the columns contain dictionaries.","category":"page"},{"location":"guide/walkthrough/ecs/","page":"Entity Component System","title":"Entity Component System","text":"Are we going to use database connectors and ORM? Not exactly, but sort of. We definitely could do it that way, but it would be much more difficult to set up. We can achieve a similar effect, however, if we use a DataFrame, an abstract type, and special methods for getproperty and setproperty!.","category":"page"},{"location":"guide/walkthrough/ecs/","page":"Entity Component System","title":"Entity Component System","text":"But what attributes is our DataFrame going to have? That depends on what semantics we want our data to have.","category":"page"},{"location":"guide/walkthrough/ecs/","page":"Entity Component System","title":"Entity Component System","text":"GUI applications, including video games, typically arrange objects in a tree, where child nodes move with their parent nodes. So we want to know what a node's local position and rotation are, and what its \"absolute\" (inherited + local) position and rotation are. We also need to keep track of parent nodes and lists of children. We need to be able to fetch nodes at any time, so being able to look them up by ID will be useful. Keeping track of the node's Julia type and instance will allow us to reuse the property-accessing semantics and apply operations to type-based subsets of nodes. Having a way to distinguish between what's visible in a window and what isn't may be useful. Finally, having a dictionary column will not only allow arbitrary properties, but it will allow users to create arbitrary custom types with appropriate semantics. This will come in handy later. A lot.","category":"page"},{"location":"guide/walkthrough/ecs/","page":"Entity Component System","title":"Entity Component System","text":"Let's start with that abstract type we mentioned. From here on out we're going to start referring to \"entities\", since they are not only nodes in a tree but also members of an entity component system.","category":"page"},{"location":"guide/walkthrough/ecs/","page":"Entity Component System","title":"Entity Component System","text":"abstract type Entity end","category":"page"},{"location":"guide/walkthrough/ecs/","page":"Entity Component System","title":"Entity Component System","text":"Let's establish what symbolic names we're going to use for our columns:","category":"page"},{"location":"guide/walkthrough/ecs/","page":"Entity Component System","title":"Entity Component System","text":"const ENT = :ent # entity, the original Julia object instance\nconst TYPE = :type\nconst ID = :id\nconst PARENT = :parent\nconst CHILDREN = :children\nconst POSITION = :pos\nconst ROTATION = :rot\nconst ABSOLUTE_POSITION = :abs_pos\nconst ABSOLUTE_ROTATION = :abs_rot\nconst HIDDEN = :hidden\nconst PROPS = :props","category":"page"},{"location":"guide/walkthrough/ecs/","page":"Entity Component System","title":"Entity Component System","text":"Position and rotation usually have X, Y, and Z components, and it's helpful to be able to refer to those components as properties. We're looking for a better way to do things, but for now the following will suffice:","category":"page"},{"location":"guide/walkthrough/ecs/","page":"Entity Component System","title":"Entity Component System","text":"mutable struct XYZ\n  x::Number\n  y::Number\n  z::Number\n  XYZ(x=0, y=0, z=0) = new(x, y, z)\nend\n\nimport Base.+, Base.-, Base.*, Base.÷, Base./, Base.%\n+(a::XYZ, b::XYZ) = XYZ(a.x+b.x,a.y+b.y,a.z+b.z)\n-(a::XYZ, b::XYZ) = XYZ(a.x-b.x,a.y-b.y,a.z-b.z)\n*(a::XYZ, b::Number) = XYZ(a.x*b,a.y*b,a.z*b)\n÷(a::XYZ, b::Number) = XYZ(a.x÷b,a.y÷b,a.z÷b)\n/(a::XYZ, b::Number) = XYZ(a.x/b,a.y/b,a.z/b)\n%(a::XYZ, b::Number) = XYZ(a.x%b,a.y%b,a.z%b)","category":"page"},{"location":"guide/walkthrough/ecs/","page":"Entity Component System","title":"Entity Component System","text":"Now we can define the types that the columns of our DataFrame will have:","category":"page"},{"location":"guide/walkthrough/ecs/","page":"Entity Component System","title":"Entity Component System","text":"const components = Dict(\n  ENT=>Entity,\n  TYPE=>DataType,\n  ID=>Number,\n  PARENT=>Number,\n  CHILDREN=>Set{Number},\n  POSITION=>XYZ,\n  ROTATION=>XYZ,\n  HIDDEN=>Bool,\n  PROPS=>Dict{Symbol, Any}\n)","category":"page"},{"location":"guide/walkthrough/ecs/","page":"Entity Component System","title":"Entity Component System","text":"Now we're almost ready to create our DataFrame. But first, a few more observations. We're still assuming a parallel environment where we don't know what order systems will be running in, so we need to synchronize access to the DataFrame. A simple lock will suffice. The ECS can also be responsible for calling the lifecycle functions of entities, but since these can be added or removed at any time, we need to know whether awake! has already been called. Finally, we need to keep track of what IDs are available and in use. A simple integer will do the trick.","category":"page"},{"location":"guide/walkthrough/ecs/","page":"Entity Component System","title":"Entity Component System","text":"With that our DataFrame and ECS struct become surprisingly simple:","category":"page"},{"location":"guide/walkthrough/ecs/","page":"Entity Component System","title":"Entity Component System","text":"mutable struct ECS\n  df::DataFrame\n  awoken::Bool\n  lock::ReentrantLock\n  next_id::Number\n  function ECS()\n    df = DataFrame(\n      NamedTuple{Tuple(keys(components))}(\n        t[] for t in values(components)\n      ))\n    return new(df, false, ReentrantLock(), 0)\n  end\nend","category":"page"},{"location":"guide/walkthrough/ecs/","page":"Entity Component System","title":"Entity Component System","text":"...but don't worry, there's plenty of complexity just around the corner. The reason is that we we're going to be implementing a tree structure on top of this DataFrame. We can now add an ECS to our App's constructor...","category":"page"},{"location":"guide/walkthrough/ecs/","page":"Entity Component System","title":"Entity Component System","text":"...\nsystem!(a, ECS())\n...","category":"page"},{"location":"guide/walkthrough/ecs/","page":"Entity Component System","title":"Entity Component System","text":"...and the associated helper function...","category":"page"},{"location":"guide/walkthrough/ecs/","page":"Entity Component System","title":"Entity Component System","text":"ecs() = a.systems[ECS]","category":"page"},{"location":"guide/walkthrough/ecs/","page":"Entity Component System","title":"Entity Component System","text":"...but we're not ready to implement the ECS's awake! and shutdown! just yet. We'll need to have tree traversal in place first, and for that we're going to need some custom iterators. And for that...well, we'll be looking at our entities' parent and children properties, so we'll need to start with getters and setters.","category":"page"},{"location":"guide/walkthrough/ecs/","page":"Entity Component System","title":"Entity Component System","text":"First, some helpers. The names are self-explanatory, but we encourage you to read up on the DataFrames documentation so as to understand what exactly they do.","category":"page"},{"location":"guide/walkthrough/ecs/","page":"Entity Component System","title":"Entity Component System","text":"# internally using Base.getproperty directly so\n# as to not break if the symbol values change\ngetEntityRow(ent::Entity) = @view ecs().df[getproperty(ecs().df, ENT) .== [ent], :]\nfunction getEntityById(id::Number)\n  arr = ecs().df[getproperty(ecs().df, ID) .== [id], ENT]\n  if length(arr) > 0\n    return arr[1]\n  end\n  return nothing\nend\ngetEntityRowById(id::Number) = @view ecs().df[getproperty(ecs().df, ID) .== [id], :]\ngetDfRowProp(r, s) = r[!, s][1]\nsetDfRowProp!(r, s, x) = r[!, s][1] = x","category":"page"},{"location":"guide/walkthrough/ecs/","page":"Entity Component System","title":"Entity Component System","text":"Then a bit more custom-property boilerplate:","category":"page"},{"location":"guide/walkthrough/ecs/","page":"Entity Component System","title":"Entity Component System","text":"function Base.propertynames(ent::Entity)\n  return (\n    keys(components)...,\n    ABSOLUTE_POSITION,\n    ABSOLUTE_ROTATION,\n    [n for n in keys(getproperty(ent, PROPS))]...\n  )\nend\n\nfunction Base.hasproperty(ent::Entity, s::Symbol)\n  return s in Base.propertynames(ent)\nend","category":"page"},{"location":"guide/walkthrough/ecs/","page":"Entity Component System","title":"Entity Component System","text":"Then the fun part:","category":"page"},{"location":"guide/walkthrough/ecs/","page":"Entity Component System","title":"Entity Component System","text":"function accumulate_XYZ(r, s)\n  acc = XYZ()\n  while true\n    inc = getDfRowProp(r, s)\n    acc += inc\n    r = getEntityRowById(getDfRowProp(r, PARENT))\n    getDfRowProp(r, PARENT) != 0 || return acc\n  end\nend\n\nfunction Base.getproperty(ent::Entity, s::Symbol)\n  e = getEntityRow(ent)\n  if s == ABSOLUTE_POSITION return accumulate_XYZ(e, POSITION)\n  elseif s == ABSOLUTE_ROTATION return accumulate_XYZ(e, ROTATION)\n  elseif s in keys(components) return getDfRowProp(e, s)\n  elseif s in keys(getDfRowProp(e, PROPS)) return getDfRowProp(e, PROPS)[s]\n  else return getfield(ent, s)\n  end\nend\n\nfunction Base.setproperty!(ent::Entity, s::Symbol, x)\n  e = getEntityRow(ent)\n  if s in [\n    ENT, # immutable\n    TYPE, # automatically set\n    ID, # automatically set\n    ABSOLUTE_POSITION, # computed\n    ABSOLUTE_ROTATION # computed\n  ]\n    error(\"cannot set property $(s) on Entity\")\n  end\n\n  lock(ecs().lock)\n  if s == PARENT\n    par = getEntityById(getDfRowProp(e, PARENT))\n    push!(getproperty(par, CHILDREN), getDfRowProp(e, ID))\n  elseif s in keys(components) && s != PROPS\n    setDfRowProp!(e, s, x)\n  else\n    getDfRowProp(e, PROPS)[s] = x\n  end\n  unlock(ecs().lock)\nend","category":"page"},{"location":"guide/walkthrough/ecs/","page":"Entity Component System","title":"Entity Component System","text":"We just threw a lot at you. Take some time to digest it before moving on.","category":"page"},{"location":"guide/walkthrough/ecs/","page":"Entity Component System","title":"Entity Component System","text":"We're going to want to use map with awake! on entities, which means we need a custom iterator type for the ECS as well as a length function. Since we'll eventually want to iterate multiple different ways, we'll define special iterator types rather than just an iterator for ECS. The first one will be Level, i.e. traversing nodes by tree level, or in breadth-first order.","category":"page"},{"location":"guide/walkthrough/ecs/","page":"Entity Component System","title":"Entity Component System","text":"This is all we need to make that happen:","category":"page"},{"location":"guide/walkthrough/ecs/","page":"Entity Component System","title":"Entity Component System","text":"Base.length(e::ECS) = size(e.df)[1]\n\nstruct Level end \nBase.length(l::Level) = length(ecs())\n\nmutable struct ECSIteratorState\n  root::Number\n  q::Queue{Number}\n  root_visited::Bool\n  index::Number\n  ECSIteratorState(; root=0, q=Queue{Number}(), \n  root_visited=false, index=1) = new(root, q, root_visited, index)\nend\n\nfunction Base.iterate(l::Level, state::ECSIteratorState=ECSIteratorState())\n  if isempty(state.q)\n    if !state.root_visited # just started\n      enqueue!(state.q, state.root)\n      state.root_visited = true\n    else # just finished\n      return nothing\n    end\n  end\n\n  ent = getEntityById(dequeue!(state.q))\n\n  for c in getproperty(ent, CHILDREN) \n    enqueue!(state.q, c)\n  end\n\n  return (ent, state)\nend","category":"page"},{"location":"guide/walkthrough/ecs/","page":"Entity Component System","title":"Entity Component System","text":"Now we can add awake! and shutdown!:","category":"page"},{"location":"guide/walkthrough/ecs/","page":"Entity Component System","title":"Entity Component System","text":"function awake!(e::ECS)\n  e.awoken = true\n  map(awake!, Level())\n  listenFor(e, TICK)\nend\n\nfunction shutdown!(e::ECS)\n  unlistenFrom(e, TICK)\n  map(shutdown!, Level())\n  e.awoken = false\nend","category":"page"},{"location":"guide/walkthrough/ecs/","page":"Entity Component System","title":"Entity Component System","text":"And about that tick handler...having entities that call an update function every frame is a very common use case that we want to support. We could just define tick handlers for all new entity types, but that's a lot of boilerplate and doesn't allow us to ensure that entities are updated in a deterministic order, in case that becomes important. So we have the following:","category":"page"},{"location":"guide/walkthrough/ecs/","page":"Entity Component System","title":"Entity Component System","text":"update!(e, Δ) = nothing\n\nfunction handleMessage!(e::ECS, m::TICK)\n  map((ent) -> update!(ent, m.Δ), Level()) \nend","category":"page"},{"location":"guide/walkthrough/ecs/","page":"Entity Component System","title":"Entity Component System","text":"Now entities can simply define an update! method and it will be called every frame deterministically.","category":"page"},{"location":"guide/walkthrough/ecs/","page":"Entity Component System","title":"Entity Component System","text":"So we can work with entities and with the ECS, but how do we actually add and remove entities?","category":"page"},{"location":"guide/walkthrough/ecs/","page":"Entity Component System","title":"Entity Component System","text":"We have to handle assigning their ID's, keeping parent and child information updated, and also allow users to define any initial values for custom properties. Notice that we've been assuming that there is a \"root\" note with an ID of 0. This is the first entity that will be created, and we'll get to it in a moment.","category":"page"},{"location":"guide/walkthrough/ecs/","page":"Entity Component System","title":"Entity Component System","text":"But first, here's how you add a new entity instance to the ECS:","category":"page"},{"location":"guide/walkthrough/ecs/","page":"Entity Component System","title":"Entity Component System","text":"function instantiate!(e::Entity; kw...)\n  lock(ecs().lock)\n\n  id = ecs().next_id\n  ecs().next_id += 1\n\n  push!(ecs().df, Dict(\n    ENT=>e,\n    TYPE=>typeof(e),\n    ID=>id,\n    CHILDREN=>get(kw, CHILDREN, Set{Number}()),\n    PARENT=>get(kw, PARENT, 0),\n    POSITION=>get(kw, POSITION, XYZ()),\n    ROTATION=>get(kw, ROTATION, XYZ()),\n    HIDDEN=>get(kw, HIDDEN, false),\n    PROPS=>merge(get(kw, PROPS, Dict{Symbol, Any}()), \n      Dict(k=>v for (k,v) in kw if k ∉ \n      [CHILDREN, PARENT, POSITION, ROTATION, HIDDEN, PROPS]))\n  ))\n\n  if id != 0\n    par = getEntityById(get(kw, PARENT, 0))\n    push!(getproperty(par, CHILDREN), id)\n  end\n\n  unlock(ecs().lock)\n\n  if ecs().awoken awake!(e) end\n\n  return e\nend","category":"page"},{"location":"guide/walkthrough/ecs/","page":"Entity Component System","title":"Entity Component System","text":"And here's how you remove them:","category":"page"},{"location":"guide/walkthrough/ecs/","page":"Entity Component System","title":"Entity Component System","text":"function destroy!(e::Entity)\n  shutdown!(e)\n\n  lock(ecs().lock)\n\n  p = getEntityById(getproperty(e, PARENT))\n\n  # if not root\n  if getproperty(p, ID) != getproperty(e, ID)\n    # update parent\n    delete!(getproperty(p, CHILDREN), getproperty(e, ID))\n    # update dataframe\n    deleteat!(ecs().df, getproperty(ecs().df, ENT) .== [e])\n  end\n\n  unlock(ecs().lock)\nend\n\nfunction destroy!(es...)\n  map(destroy!, es)\nend","category":"page"},{"location":"guide/walkthrough/ecs/","page":"Entity Component System","title":"Entity Component System","text":"And now we have a functioning entity component system.","category":"page"},{"location":"guide/walkthrough/ecs/","page":"Entity Component System","title":"Entity Component System","text":"And that's all so far as Starlight's core subsystems go. To do anything meaningful you'll need to hook up a backend for things like input, rendering, and physics, but that will be much easier now that we've established a means to create new subsystems and allow them to communicate and share objects.","category":"page"},{"location":"guide/walkthrough/ecs/","page":"Entity Component System","title":"Entity Component System","text":"This is also the end of the \"framework from scratch\" narrative. Everything else in the Starlight package is tailored for video games, which may not be your use case. The \"framework\" as such is pretty much complete at this point.","category":"page"},{"location":"guide/walkthrough/ecs/","page":"Entity Component System","title":"Entity Component System","text":"If you want to make video games or otherwise use Starlight's default backend, Telescope, read on. Otherwise you're better off reading the API docs, or even striking out on your own to extend Starlight for whatever your personal use case is.","category":"page"},{"location":"guide/telescope/physics/#Physics","page":"Physics","title":"Physics","text":"","category":"section"},{"location":"guide/telescope/physics/","page":"Physics","title":"Physics","text":"Starlight provides a default subsystem for conveniently working with Telescope's Bullet integration. Explaining all of how it works would require an explanation of Bullet itself, but we'll attempt a high-level overview of the most important things it does.","category":"page"},{"location":"guide/telescope/physics/","page":"Physics","title":"Physics","text":"mutable struct PhysicsObjectInfo\n  hx::AbstractFloat\n  hy::AbstractFloat\n  hz::AbstractFloat\n  m::AbstractFloat\n  isKinematic::Bool\n  mx::AbstractFloat\n  my::AbstractFloat\n  mz::AbstractFloat\n  PhysicsObjectInfo(hx = 0, hy = 0, hz = 0, m = 0, isKinematic = false, mx = 0, my = 0, mz = 0) = new(hx, hy, hz, m, isKinematic, mx, my, mz)\nend\n\nmutable struct Physics \n  ids::Dict{Number, PhysicsObjectInfo}\n  Physics() = new(Dict{Number, PhysicsObjectInfo}())\nend\n\nfunction handleMessage!(p::Physics, m::TICK)\n  TS_BtStepSimulation()\n  for (id, pinfo) in p.ids\n    pos = TS_BtGetPosition(id)\n    # TODO: this is a bad hack for working specifically with rectangular objects, needs improvement\n    getEntityById(id).pos = XYZ(pos.x - pinfo.hx, pos.y - pinfo.hy, pos.z - pinfo.hz)\n  end\n  while true\n    col = TS_BtGetNextCollision()\n    if col.id1 == -1 && col.id2 == -1 break end\n    e1 = getEntityById(col.id1)\n    e2 = getEntityById(col.id2)\n    handleMessage!(e1, col)\n    handleMessage!(e2, col)\n  end\nend\n\nfunction awake!(p::Physics)\n  listenFor(p, TICK)\nend\n\nfunction shutdown!(p::Physics)\n  unlistenFrom(p, TICK)\nend","category":"page"},{"location":"guide/telescope/physics/","page":"Physics","title":"Physics","text":"Basically there is a struct, PhysicsObjectInfo, that Starlight uses to keep track of the physics entities created using its API (which is not shown, but uses Telescope's Bullet-related APIs). The tick handler tells Bullet to update its internal state (\"simulation\"), then takes care of updating the positions of any objects that have moved as well as dispatching collision events.","category":"page"},{"location":"guide/telescope/physics/","page":"Physics","title":"Physics","text":"Note that for now collision handlers (handleMessage! methods where the message has type TS_CollisionEvent) are invoked directly by the physics system rather than through the message dispatcher. Changing this would be complicated, since it requires the message dispatcher to know about \"message recipients\" or some such (since all it does currently is broadcast based on message type), which would also require changes to listenFor and unlistenFrom. However there are in fact plans to make those changes, since ideally all events would go through the dispatcher, and doing so would both simplify the existing physics code and make it easier to implement alternative physics subsystems.","category":"page"},{"location":"guide/walkthrough/clock/#Clock","page":"Clock","title":"Clock","text":"","category":"section"},{"location":"guide/walkthrough/clock/","page":"Clock","title":"Clock","text":"So we need a Clock subsystem which uses its awake! and shutdown! functions to synchronize coroutines, and which also fires a periodic time event or \"tick\".","category":"page"},{"location":"guide/walkthrough/clock/","page":"Clock","title":"Clock","text":"All of our coroutines need to be able to wait for the Clock to start, since they can be schedule any time before awake! is called. Ones that run periodically in the background need to be able to check whether the clock is still running, and the Clock itself needs to know how often to fire its tick event.","category":"page"},{"location":"guide/walkthrough/clock/","page":"Clock","title":"Clock","text":"We can start with the following struct:","category":"page"},{"location":"guide/walkthrough/clock/","page":"Clock","title":"Clock","text":"mutable struct Clock\n  started::Base.Event\n  stopped::Bool\n  freq::AbstractFloat\n  Clock() = new(Base.Event(), true, 0.01667) # 60 Hz\nend","category":"page"},{"location":"guide/walkthrough/clock/","page":"Clock","title":"Clock","text":"Background tasks might be scheduled as follows, with an optional arg parameter in case arguments need to be passed:","category":"page"},{"location":"guide/walkthrough/clock/","page":"Clock","title":"Clock","text":"function job!(c::Clock, f, arg=1)\n  function job()\n    Base.wait(c.started)\n    while !c.stopped\n      f(arg)\n    end\n  end\n  schedule(Task(job))\nend","category":"page"},{"location":"guide/walkthrough/clock/","page":"Clock","title":"Clock","text":"One-off tasks might look similar, just without the loop:","category":"page"},{"location":"guide/walkthrough/clock/","page":"Clock","title":"Clock","text":"function oneshot!(c::Clock, f, arg=1)\n  function oneshot()\n    Base.wait(c.started)\n    f(arg)\n  end\n  schedule(Task(oneshot))\nend","category":"page"},{"location":"guide/walkthrough/clock/","page":"Clock","title":"Clock","text":"What about firing tick events? How do we tell a background job to wait a certain length of time between executions, since it just gets called in an infinite loop? We could try using sleep, but that only gives us millisecond resolution. Fortunately Julia provides the tools we need to implement our own nanosecond sleep function, and it's not likely we'll need finer resolution than that.","category":"page"},{"location":"guide/walkthrough/clock/","page":"Clock","title":"Clock","text":"struct TICK\n  Δ::AbstractFloat\nend\n\nstruct SLEEP_NSEC\n  Δ::UInt\nend\n\nfunction Base.sleep(s::SLEEP_NSEC)\n  t1 = time_ns()\n  while true\n    if time_ns() - t1 >= s.Δ break end\n    yield()\n  end\n  return time_ns() - t1\nend\n\nfunction tick(Δ)\n  δ = sleep(SLEEP_NSEC(Δ * 1e9))\n  sendMessage(TICK(δ / 1e9))\nend","category":"page"},{"location":"guide/walkthrough/clock/","page":"Clock","title":"Clock","text":"Now we have everything we need to implement the Clock's awake! and shutdown! functions:","category":"page"},{"location":"guide/walkthrough/clock/","page":"Clock","title":"Clock","text":"function awake!(c::Clock)\n  job!(c, tick, c.freq)\n  c.stopped = false\n  Base.notify(c.started)\nend\n\nfunction shutdown!(c::Clock)\n  c.stopped = true\n  c.started = Base.Event() # old one remains signaled no matter what, replace\nend","category":"page"},{"location":"guide/walkthrough/clock/","page":"Clock","title":"Clock","text":"But we still need to tell the App about the Clock. Change the constructor's if block:","category":"page"},{"location":"guide/walkthrough/clock/","page":"Clock","title":"Clock","text":"...\na = new(Dict{DataType, Any}(), false)\nsystem!(a, Clock())\n...","category":"page"},{"location":"guide/walkthrough/clock/","page":"Clock","title":"Clock","text":"We can add an accessor function to get the \"global clock\":","category":"page"},{"location":"guide/walkthrough/clock/","page":"Clock","title":"Clock","text":"clk() = app[].systems[Clock]","category":"page"},{"location":"guide/walkthrough/clock/","page":"Clock","title":"Clock","text":"And now we can add the message dispatcher to awake!:","category":"page"},{"location":"guide/walkthrough/clock/","page":"Clock","title":"Clock","text":"function awake!(a::App)\n  if !on(a)\n    job!(clk(), dispatchMessage)\n    map(awake!, values(a.systems))\n    a.running = true\n  end\nend","category":"page"},{"location":"guide/walkthrough/clock/","page":"Clock","title":"Clock","text":"If you add debug output to your code so far and run it, you'll notice it merrily dispatching and processing tick events at 60 Hz (after some startup lag from the compiler) much like in our earlier example.","category":"page"},{"location":"guide/walkthrough/clock/","page":"Clock","title":"Clock","text":"The current approach of adding subsystems to the App doesn't scale well, since it requires modifying the constructor and adding a helper function for each subsystem. It's fine for a few important \"static\" systems that are considered part of the framework itself, but not for the vast number of objects that will be dynamically created, updated, used, and deleted within the lifetime of even a moderately complex program. And yet we still want these objects to be able to hook into the framework somehow so that they can be shared among subsystes and managed by the App. We can accomplish this with an Entity Component System.","category":"page"},{"location":"guide/telescope/input/#Input","page":"Input","title":"Input","text":"","category":"section"},{"location":"guide/telescope/input/","page":"Input","title":"Input","text":"Starlight's event bus makes designing an input system trivial. All that's required is a tick handler with some basic processing and users are free to define handlers for any event type supported by SDL. Understanding that Input is a subsystem that follows the same pattern as the others, its entire source code is almost exactly the following:","category":"page"},{"location":"guide/telescope/input/","page":"Input","title":"Input","text":"mutable struct Input end\n\nfunction awake!(i::Input)\n  listenFor(i, TICK)\nend\n\nfunction shutdown!(i::Input)\n  unlistenFrom(i, TICK)\nend\n\nfunction handleMessage!(i::Input, m::TICK)\n  evt_ref = Ref{SDL_Event}()\n  while Bool(SDL_PollEvent(evt_ref))\n    evt = evt_ref[]\n    ty = evt.type\n    if ty ∈ [SDL_AUDIODEVICEADDED, SDL_AUDIODEVICEREMOVED]\n      sendMessage(evt.adevice)\n    elseif ty == SDL_CONTROLLERAXISMOTION\n      sendMessage(evt.caxis)\n    elseif ty ∈ [SDL_CONTROLLERBUTTONDOWN, SDL_CONTROLLERBUTTONUP]\n      sendMessage(evt.cbutton)\n    elseif ty ∈ [SDL_CONTROLLERDEVICEADDED, SDL_CONTROLLERDEVICEREMOVED, SDL_CONTROLLERDEVICEREMAPPED]\n      sendMessage(evt.cdevice)\n    elseif ty ∈ [SDL_DOLLARGESTURE, SDL_DOLLARRECORD]\n      sendMessage(evt.dgesture)\n    elseif ty ∈ [SDL_DROPFILE, SDL_DROPTEXT, SDL_DROPBEGIN, SDL_DROPCOMPLETE]\n      sendMessage(evt.drop)\n    elseif ty ∈ [SDL_FINGERMOTION, SDL_FINGERDOWN, SDL_FINGERUP]\n      sendMessage(evt.tfinger)\n    elseif ty ∈ [SDL_KEYDOWN, SDL_KEYUP]\n      sendMessage(evt.key)\n    elseif ty == SDL_JOYAXISMOTION\n      sendMessage(evt.jaxis)\n    elseif ty == SDL_JOYBALLMOTION\n      sendMessage(evt.jball)\n    elseif ty == SDL_JOYHATMOTION\n      sendMessage(evt.jhat)\n    elseif ty ∈ [SDL_JOYBUTTONDOWN, SDL_JOYBUTTONUP]\n      sendMessage(evt.jbutton)\n    elseif ty ∈ [SDL_JOYDEVICEADDED, SDL_JOYDEVICEREMOVED]\n      sendMessage(evt.jdevice)\n    elseif ty == SDL_MOUSEMOTION\n      sendMessage(evt.motion)\n    elseif ty ∈ [SDL_MOUSEBUTTONDOWN, SDL_MOUSEBUTTONUP]\n      sendMessage(evt.button)\n    elseif ty == SDL_MOUSEWHEEL\n      sendMessage(evt.wheel)\n    elseif ty == SDL_MULTIGESTURE\n      sendMessage(evt.mgesture)\n    elseif ty == SDL_QUIT\n      sendMessage(evt.quit)\n    elseif ty == SDL_SYSWMEVENT\n      sendMessage(evt.syswm)\n    elseif ty == SDL_TEXTEDITING\n      sendMessage(evt.edit)\n    elseif ty == SDL_TEXTINPUT\n      sendMessage(evt.text)\n    elseif ty == SDL_USEREVENT\n      sendMessage(evt.user)\n    elseif ty == SDL_WINDOWEVENT\n      sendMessage(evt.window)\n    else\n      sendMessage(evt)\n    end\n  end\nend","category":"page"},{"location":"guide/telescope/input/","page":"Input","title":"Input","text":"Note the direct use of the SDL2 wrapper. Starlight initializes SDL via Telescope, but if you want implement your own subsystems that use SDL directly or through a different wrapper or however, you're free to do so, Starlight's default input system will at least still work (although you will need to provide replacements for several structs and other subsystems).","category":"page"},{"location":"guide/telescope/input/","page":"Input","title":"Input","text":"You are encouraged to read SDL's documentation for events in order to understand how Starlight's input system works. Essentially, you listenFor/unlistenFrom and handleMessage! for SDL's event types as exposed through the wrapper, and Starlight will handle translating from the raw SDL_Event for you.","category":"page"},{"location":"guide/telescope/input/","page":"Input","title":"Input","text":"The Pong example code contains several input handlers that you can reference if things are still unclear.","category":"page"},{"location":"guide/telescope/rendering/#Rendering","page":"Rendering","title":"Rendering","text":"","category":"section"},{"location":"guide/telescope/rendering/","page":"Rendering","title":"Rendering","text":"Entities that get drawn on the screen must satisfy several requirements:","category":"page"},{"location":"guide/telescope/rendering/","page":"Rendering","title":"Rendering","text":"They must inherit from the abstract type Starlight.Renderable, since the scene graph culls objects based on type\nThey must be registered in the ECS using instantiate!, or the scene graph will not see them\nThey must define a draw method.","category":"page"},{"location":"guide/telescope/rendering/","page":"Rendering","title":"Rendering","text":"Here is an example from Starlight's source code:","category":"page"},{"location":"guide/telescope/rendering/","page":"Rendering","title":"Rendering","text":"mutable struct ColorRect <: Renderable\n  function ColorRect(w, h; color=colorant\"white\", kw...)\n    instantiate!(new(); w=w, h=h, color=color, kw...)\n  end\nend\n\ndefaultDrawRect(r) = TS_VkCmdDrawRect(\n  vulkan_colors(r.color)..., \n  r.abs_pos.x, r.abs_pos.y, r.w, r.h)\n\ndraw(r::ColorRect) = defaultDrawRect(r)","category":"page"},{"location":"guide/telescope/rendering/","page":"Rendering","title":"Rendering","text":"...where vulkan_colors is a helper to convert Colorants to the color format expected by Telescope/Vulkan.","category":"page"},{"location":"guide/telescope/rendering/","page":"Rendering","title":"Rendering","text":"Note that the real magic takes place in TS_VkCmdDrawRect, which is Telescope's API for specifically drawing rectangles. If you are using the Telescope backend, you are not able to draw anything that the API doesn't provide explicit support for, although you can compose supported \"drawables\" using for-loops and such inside your draw function.","category":"page"},{"location":"guide/telescope/rendering/","page":"Rendering","title":"Rendering","text":"Note too that properties are registered in the ECS rather than in the struct definition, as is true for all entities. You can still use struct fields, but they are only ever be referenced if the instance has no ECS attributes with the same name.","category":"page"},{"location":"guide/telescope/rendering/","page":"Rendering","title":"Rendering","text":"Finally, note the mix of property names. Some are constants defined as permanent columns of the underlying DataFrame, and others go to the props dictionary.","category":"page"},{"location":"guide/telescope/rendering/","page":"Rendering","title":"Rendering","text":"The only other Renderable exported by Starlight is Sprite:","category":"page"},{"location":"guide/telescope/rendering/","page":"Rendering","title":"Rendering","text":"mutable struct Sprite <: Renderable\n  function Sprite(img; cell_size=[0, 0], region=[0, 0, 0, 0], cell_ind=[0, 0], \n    color=colorant\"white\", scale=XYZ(1,1,1), kw...)\n    instantiate!(new(); img=img, cell_size=cell_size, \n      region=region, cell_ind=cell_ind, color=color,\n      scale=scale, kw...)\n  end\nend\n\ndefaultDrawSprite(s) = TS_VkCmdDrawSprite(s.img, \n  vulkan_colors(s.color)..., \n  s.region[1], s.region[2], s.region[3], s.region[4], \n  s.cell_size[1], s.cell_size[2], s.cell_ind[1], s.cell_ind[2],\n  s.abs_pos.x, s.abs_pos.y, s.scale.x, s.scale.y)\n\ndraw(s::Sprite) = defaultDrawSprite(s)","category":"page"},{"location":"guide/telescope/rendering/","page":"Rendering","title":"Rendering","text":"More Renderable's will be \"natively\" supported in the future, if there's one in particular you'd like to see then feel free to create an issue or, better still, submit a pull request.","category":"page"},{"location":"guide/telescope/rendering/","page":"Rendering","title":"Rendering","text":"These are not a high priority for now though, since sprites and rectangles are sufficient for almost all 2D use cases, and 3D is not a priority (although we're happy to make it a priority if you get in touch, see the README for contact info).","category":"page"},{"location":"guide/telescope/rendering/","page":"Rendering","title":"Rendering","text":"However, check out the Pong example for an idea of what can be done by composing sprites and rectangles.","category":"page"},{"location":"guide/telescope/rendering/","page":"Rendering","title":"Rendering","text":"There are two final Telescope-dependent subsystems to cover: input and physics.","category":"page"},{"location":"guide/walkthrough/getting-started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"guide/walkthrough/getting-started/","page":"Getting Started","title":"Getting Started","text":"Starlight aims to offload as much work as possible onto the underlying libraries while still giving you, the developer, fine-grained control over your application's behavior: it provides useful abstraction, but gets out of the way when you need it to. The reason it can do this is its microkernel architecture, which models all subsystems as running independently of each other while exchanging data through a message bus. What exactly this means and how it works will be explained shortly. To give you an idea what to expect, let's review some content from the README. ","category":"page"},{"location":"guide/walkthrough/getting-started/","page":"Getting Started","title":"Getting Started","text":"To get started with Starlight, first add it to your project:","category":"page"},{"location":"guide/walkthrough/getting-started/","page":"Getting Started","title":"Getting Started","text":"julia> ] add Starlight","category":"page"},{"location":"guide/walkthrough/getting-started/","page":"Getting Started","title":"Getting Started","text":"You can then declare that you are","category":"page"},{"location":"guide/walkthrough/getting-started/","page":"Getting Started","title":"Getting Started","text":"julia> using Starlight","category":"page"},{"location":"guide/walkthrough/getting-started/","page":"Getting Started","title":"Getting Started","text":"From there, in order to initialize the various subsystems, you must create an App:","category":"page"},{"location":"guide/walkthrough/getting-started/","page":"Getting Started","title":"Getting Started","text":"julia> a = App()","category":"page"},{"location":"guide/walkthrough/getting-started/","page":"Getting Started","title":"Getting Started","text":"To kick everything off and open a window, you can call","category":"page"},{"location":"guide/walkthrough/getting-started/","page":"Getting Started","title":"Getting Started","text":"julia> awake!(a)","category":"page"},{"location":"guide/walkthrough/getting-started/","page":"Getting Started","title":"Getting Started","text":"To shut everything down, you (fittingly) call","category":"page"},{"location":"guide/walkthrough/getting-started/","page":"Getting Started","title":"Getting Started","text":"julia> shutdown!(a)","category":"page"},{"location":"guide/walkthrough/getting-started/","page":"Getting Started","title":"Getting Started","text":"Starlight scripts should use run! instead of awake! to keep the Julia process alive. A minimal Starlight script could look something like the following:","category":"page"},{"location":"guide/walkthrough/getting-started/","page":"Getting Started","title":"Getting Started","text":"using Starlight\n\na = App()\n\nrun!(a)","category":"page"},{"location":"guide/walkthrough/getting-started/","page":"Getting Started","title":"Getting Started","text":"Doing that in a shell session with debug output enabled gives you an idea of just how much is going on behind the blank window that gets created:","category":"page"},{"location":"guide/walkthrough/getting-started/","page":"Getting Started","title":"Getting Started","text":"jhigginbotham64:Starlight (main) $ JULIA_DEBUG=Starlight julia -e 'using Starlight; a = App(); run!(a)'\n┌ Debug: Clock awake!\n└ @ Starlight ~/.julia/dev/Starlight/src/Clock.jl:66\n┌ Debug: TS awake!\n└ @ Starlight ~/.julia/dev/Starlight/src/TS.jl:41\n┌ Debug: dispatchMessage\n└ @ Starlight ~/.julia/dev/Starlight/src/Starlight.jl:57\n┌ Debug: Input awake!\n└ @ Starlight ~/.julia/dev/Starlight/src/Input.jl:64\n┌ Debug: tick\n└ @ Starlight ~/.julia/dev/Starlight/src/Clock.jl:44\n┌ Debug: Physics awake!\n└ @ Starlight ~/.julia/dev/Starlight/src/Physics.jl:64\n┌ Debug: dequeued message TICK(1.99813325) of type TICK\n└ @ Starlight ~/.julia/dev/Starlight/src/Starlight.jl:61\n┌ Debug: ECS awake!\n└ @ Starlight ~/.julia/dev/Starlight/src/ECS.jl:198\n┌ Debug: tick\n└ @ Starlight ~/.julia/dev/Starlight/src/Clock.jl:44\n┌ Debug: Scene awake!\n└ @ Starlight ~/.julia/dev/Starlight/src/ECS.jl:289\n┌ Debug: TS tick\n└ @ Starlight ~/.julia/dev/Starlight/src/TS.jl:15\n┌ Debug: Input tick\n└ @ Starlight ~/.julia/dev/Starlight/src/Input.jl:6\n┌ Debug: tick\n└ @ Starlight ~/.julia/dev/Starlight/src/Clock.jl:44\n┌ Debug: Physics tick\n└ @ Starlight ~/.julia/dev/Starlight/src/Physics.jl:45\n┌ Debug: dispatchMessage\n└ @ Starlight ~/.julia/dev/Starlight/src/Starlight.jl:57\n┌ Debug: dequeued message TICK(0.191819018) of type TICK\n└ @ Starlight ~/.julia/dev/Starlight/src/Starlight.jl:61","category":"page"},{"location":"guide/walkthrough/getting-started/","page":"Getting Started","title":"Getting Started","text":"There are several things to notice here. First and most importantly is that all subsystems (including the clock) communicate using the same event bus (you'll soon see that they even define methods for the same functions). Second is that pretty much nothing happens until awake! is called on the App. Finally, there is a clock synchronizing everything. ","category":"page"},{"location":"guide/walkthrough/getting-started/","page":"Getting Started","title":"Getting Started","text":"We're going to dwell on each of these points in turn before diving into the more specialized individual subsystems.","category":"page"},{"location":"guide/walkthrough/intro/#Intro","page":"Intro","title":"Intro","text":"","category":"section"},{"location":"guide/walkthrough/intro/","page":"Intro","title":"Intro","text":"This walkthrough follows a storytelling approach where a Starlight-like framework is built from scratch. Hopefully this will help you understand the source code better. In any case it is highly recommended that you read everything in order, at least the first time.","category":"page"},{"location":"guide/walkthrough/intro/","page":"Intro","title":"Intro","text":"It also presupposes knowledge of the Julia programming language. Patterns will be discussed, but core features like multiple dispatch will not. Make sure you have a good grasp of Julia before proceeding.","category":"page"},{"location":"guide/walkthrough/intro/","page":"Intro","title":"Intro","text":"note: Note\nThe struct and method names used in this walkthrough are mostly  the same as the ones used in Starlight's own source code. By  reading the guide you learn not only Starlight's \"core\" API but  its source code as well, albeit in slightly simplified form.","category":"page"},{"location":"guide/walkthrough/intro/","page":"Intro","title":"Intro","text":"warning: Warning\nThe purpose of this walkthrough is to prepare you to read the  API docs and source code, but not everything there is the same  as in the walkthgouh. Use this walkthrough to ground yourself in  Starlight's design philosophy and core concepts, but try not to  confuse the \"classroom\" and \"real world\" versions.","category":"page"},{"location":"guide/telescope/intro/#Intro","page":"Intro","title":"Intro","text":"","category":"section"},{"location":"guide/telescope/intro/","page":"Intro","title":"Intro","text":"Here's the motivation behind Telescope: we wanted to use Vulkan for rendering, but couldn't find a good way to create a rendering context using Julia alone. Not even with the (fantastic) SDL2 wrapper (which Starlight still uses for input events).","category":"page"},{"location":"guide/telescope/intro/","page":"Intro","title":"Intro","text":"We also wanted to use the Bullet Physics SDK for physics and especially collision detection, but...no Julia bindings have been created yet.","category":"page"},{"location":"guide/telescope/intro/","page":"Intro","title":"Intro","text":"So we opted to kill two birds with one stone: create our own C++ library to wrap the C/C++ libraries we wanted to use, expose a simple procedural/imperative API through a C header, and create (i.e. generate using Clang.jl) a simple Julia wrapper. Many Yggdrasil pull requests later, Telescope was available as a backend for Starlight.","category":"page"},{"location":"guide/telescope/intro/","page":"Intro","title":"Intro","text":"Starlight's TS subsystem simplifies Telescope's usage by handling initialization, deinitialization, and the frame-by-frame drawing context, but that's really it. Its only job is to make sure that the APIs exposed by the wrapper function as-advertised.","category":"page"},{"location":"guide/telescope/intro/","page":"Intro","title":"Intro","text":"The most important parts of the TS subsystem go something like this:","category":"page"},{"location":"guide/telescope/intro/","page":"Intro","title":"Intro","text":"function awake!(t::TS)\n  TS_Init(\"Hello SDL!\", App().wdth, App().hght)\n  draw()\n  listenFor(t, TICK)\nend\n\nfunction shutdown!(t::TS) \n  unlistenFrom(t, TICK)\n  TS_Quit()\nend\n\ndraw(e) = nothing\n\nfunction draw()\n  TS_VkBeginDrawPass()\n\n  map(draw, scn())\n\n  TS_VkEndDrawPass(vulkan_colors(App().bgrd)...)\nend\n\nfunction handleMessage!(t::TS, m::TICK)\n  draw()\nend","category":"page"},{"location":"guide/telescope/intro/","page":"Intro","title":"Intro","text":"...where wdth and hght are attributes added to the App struct to specify window dimensions and scn() refers to a special ECSIterator doubling as a new \"scene graph\" subsystem, which returns entities in reverse-z order (i.e. back to front) for drawing, and functions beginning with TS_ are calls to Telescope's Julia bindings.","category":"page"},{"location":"guide/telescope/intro/","page":"Intro","title":"Intro","text":"Next we'll cover how to create entities in such a way that they get drawn on the screen using Telescope, using an example taken (yet again) from Starlight's own source code.","category":"page"},{"location":"guide/telescope/intro/","page":"Intro","title":"Intro","text":"note: Note\nWe apologize that Telescope does not yet have documentation  available. There are plans to fix this in the near future.  Starlight's docs will be updated with relevant links to the  Telescope docs as soon as that is possible.","category":"page"},{"location":"#Starlight.jl","page":"Home","title":"Starlight.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for Starlight.jl, a greedy application framework for greedy developers. Its primary use case is video games, but the power of Julia, SDL2, Vulkan, and the Bullet Physics SDK can be leveraged to make just about anything you want.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Features of Starlight's \"core\" include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Coroutines\nEvent handling\nApp lifecycle management\nDataFrames-based entity component system","category":"page"},{"location":"","page":"Home","title":"Home","text":"Features of the default backend, Telescope, include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"SDL2 integration for windowing, audio, fonts, input, and networking\nVulkan rendering\nBullet Physics SDK integration","category":"page"},{"location":"#Guide","page":"Home","title":"Guide","text":"","category":"section"},{"location":"#Walkthrough","page":"Home","title":"Walkthrough","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n  \"guide/walkthrough/intro.md\",\n  \"guide/walkthrough/getting-started.md\",\n  \"guide/walkthrough/app-lifecycle.md\",\n  \"guide/walkthrough/message-passing.md\",\n  \"guide/walkthrough/clock.md\",\n  \"guide/walkthrough/ecs.md\"\n]","category":"page"},{"location":"#Telescope","page":"Home","title":"Telescope","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n  \"guide/telescope/intro.md\",\n  \"guide/telescope/rendering.md\",\n  \"guide/telescope/input.md\",\n  \"guide/telescope/physics.md\"\n]","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n  \"examples/pong.md\"\n]","category":"page"},{"location":"#API","page":"Home","title":"API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n  \"api.md\"\n]\nDepth = 3","category":"page"}]
}
